# Medium的微服务架构实践

原文：[Microservice Architecture at Medium]([Microservice Architecture at Medium | by Xiao Ma | Medium Engineering](https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f))

![0*ngKuAmwiyzNZK_6W](https://miro.medium.com/max/1400/0*ngKuAmwiyzNZK_6W)

微服务¹ 架构的目标是帮助工程团队更快，更安全，更高质量地交付产品。解耦服务后，团队能够快速迭代，同时确保对系统其余部分产生的影响最小。

在Medium，我们的技术栈始于2012年的单体Node.js应用程序。目前，我们已经构建了几个卫星服务，但尚未制定一个系统性采用微服务架构的策略。随着系统日趋复杂且团队不断发展壮大，我们在2018年初转向了微服务架构。在这篇文章中，我们希望为大家分享一些经验，介绍如何有效切换至微服务架构，同时避免微服务综合症。

## 什么是微服务架构？

首先，我们来思考微服务架构是什么，不是什么。微服务是被过度期望且令人困惑的软件工程趋势之一。 在Medium团队，我们认为它是：

> 在微服务架构中，多个松耦合的服务协同工作。 每项服务都专注于一个目的，并具有高内聚的相关行为和数据。

该定义囊括了微服务设计的三大原则：

- 单一性 - 每项服务应专注于一个目的并做好。
- 松耦合 - 服务彼此间没有过多联系。对一项服务的修改不会波及其他服务，服务间的通信仅通过公共服务接口进行。
- 高内聚 - 服务封装了所有相关的行为和数据，如果我们需要构建一个新特性，所有的修改应该只涉及到一个服务。

![](https://github.com/FHedy/DocItems/blob/main/source/Hacker%20News/img/14.png)

微服务设计（建模）三原则

微服务建模时，我们都应该遵守这三个设计原则。这是发挥微服务架构全部潜力的唯一途径，有悖任何一个原则都无法确保微服务架构的成功。

如果不是单一目标，每个微服务逐渐会做越来越多的事情，进而演变为多个“单体”服务。这样我们无法发挥微服务架构的所有优势，而且还会增加运维成本。

如果做不到松耦合，对一项服务的更改就会波及其它服务，因此我们无法安全快捷地发布更新。而快速迭代更新是微服务架构的核心优势。更重要的是，紧耦合可能会引发灾难性问题，比如数据不一致，甚至数据丢失。

如果没有高内聚，我们最终还是会得到一个*分布式的单体系统*，这类系统是一组混乱的服务，要求必须同时修改和部署所有服务才能构建单一功能。分布式单体系统通常比集中式单体系统的性能差很多，因为多个服务协调的过程复杂，成本高昂，有时要跨多个团队协调。

与此同时，了解微服务不是什么很重要：

1. 微服务*并不是*具有少量代码行或者“微”任务的服务，这种误解源于“微服务”这个名字。微服务架构的目标并不是有尽可能多的小型服务。只要符合上述三项原则，大体量的复杂服务也可以是“微服务”。
2. 微服务不一定是由新技术构建的服务。尽管微服务架构方便团队更便捷地测试新技术，但这并不是微服务的主要目标。只要团队能从解耦的服务中受益，我们完全可以使用相同的技术栈构建新服务。
3. 微服务不是必须要从零开始构建的服务。如果你已经有一个架构优良的单体应用程序，那么不用从零开始逐一构建新服务，可以尝试直接从单体服务中提取逻辑。再次强调，我们的设计需要始终秉承前文提到的三项原则。

## 为什么是现在?

在Medium，我们在做出重大产品或工程决策时总是会问“为什么是现在？”这个问题。

 “为什么？”是一个显而易见的问题，意味着为什么要切换至微服务架构。这个提问大胆地假设我们拥有无限的人力，时间和资源来投入。

“为什么是现在？”也就是为什么现在要切换至微服务架构。想到这个问题时，我们突然有了更多的限制条件 - 转向微服务架构后，会对当前工作、机会成本、间接费用等产生哪些影响。思考这个问题可以帮助我们更好地排列任务优先级。

我们现在需要采用微服务的原因是，Node.js单体应用程序已经面临多方面的瓶颈。

- 首先，单体应用程序最重要且紧急的瓶颈是其性能。
  Node.js不适合用于某些计算量庞大且I/O繁重的任务。我们一直在改进单体应用程序，但事实证明改进不起作用。Node.js的性能无法支撑我们交付更好的产品，只会拖慢现有应用程序的运行速度。
- 其次，一个重要且略紧急的瓶颈是，它会减慢产品开发速度。
  - 由于所有工程师都在单体应用程序中构建功能，各项功能通常紧密耦合。我们无法灵活地更改系统的某一部分，因为可能会影响其他部分；我们也害怕做出重大变更，因为影响范围太大甚至难以预测。
  - 整个应用程序作为一个整体进行部署，如果由于一次错误提交导致部署中止，那么所有其他更改即使已经完全正常工作也无法上线。

相比之下，微服务架构允许团队更快地交付，学习和迭代，各项功能与复杂系统的其余部分分离开来，他们可以专注于正在构建的功 能，更快地将变更投入生产。开发团队也可以灵活地安全地尝试重大变更。

在我们的新微服务架构中，变更会在一小时内投入生产，工程师不必担心它会影响系统的其他部分。开发团队还探索了在开发中安全使用生产数据的方法²，解决了横跨多年的难题。随着工程团队的发展壮大，所有这些转变都非常重要。

- 第三，单体应用程序不支持为特定的任务扩展系统，也不支持为不同类型的任务隔离资源。使用单一的单体应用程序时，我们必须为资源消耗型任务扩展或缩小整个系统，即使这样会导致系统过度配置资源用于其他更简单的任务。为了缓解这些问题，我们对不同类型的请求进行分类，以分离Node.js进程。这种方式有一定的作用，但不具备扩展性，因为这些微型版单体服务是紧密耦合的。

- 最后，一个重要且迫在眉睫的瓶颈是，它阻止我们尝试新技术。微服务架构的一个主要优点是，每个服务都可以使用不同的技术栈构建，并与不同的技术集成。这种特性支持我们选择最适合的工作工具，而且还能安全快捷地完成工作。

## Medium的微服务策略

采用微服务架构并非易事。它可能会出错，甚至会有损工程生产力。本节中，我们将分享采用微服务架构初期颇有帮助的七大策略：

1. 构建具有明确价值的新服务
2. 单体持久化存储是有害的
3. 解耦“构建服务”和“运行服务”
4. 彻底而一致的可观察性
5. 并非每项新服务都需要从头开始构建
6. 尊重失败
7. 从开始就避免微服务综合症

### 构建具有明确价值的新服务

有人可能会认为，采用新的服务架构意味着需要长时间暂停产品开发，并对所有内容进行大量重写。这是错误的想法。我们不应该为了构建而去构建新服务，每次构建新服务或采用新技术时，都必须有明确的产品价值/工程价值。

产品价值应该体现在我们可以为用户提供的利益。相比在单体Node.js应用程序中构建，微服务架构中构建的新服务需要能够更快地交付产品价值，同时，能够为工程团队带来更加快捷高效的工程价值。

如果构建新服务不具备产品价值或工程价值，我们会将其保留在单体应用程序中。即使十年内Medium仍然有一个支持某些接口的单体Node.js应用程序，也完全没问题。实际上，从单体应用程序开始有助于我们对微服务进行战略性建模。

### 单体持久化存储是有害的

微服务建模中的一个重要部分就是持久化数据存储（例如数据库），服务间共享持久化数据存储是集成微服务最简单的方式，但危害极大，我们要尽量避免。

首先，持久化存储涉及到产品实现细节，服务间共享数据存储会把服务的实现细节暴露给整个系统，如果这个服务更改了数据格式，或者添加了一个缓存层，其他服务就要跟着做相应的更改，这种做法严重违背了松耦合原则。

其次，持久化数据存储并不是服务行为，也就是数据的更改、解析和使用。如果服务间共享数据存储，那么其他服务也必须复制这些服务行为。这违背了高内聚原则 - 指定领域的行为暴露给了多项服务，如果修改某个行为，其它相关服务都必须要跟着修改。

> 在微服务架构中，一种特定类型的数据应该只由一个服务负责，其他服务应该通过API调用此服务来请求数据，或者仅保留数据的只读副本。

这个过程听起来可能很抽象，下面来看一个实际的例子。比如，要构建一个新推荐服务，需要用到标准Post表中的数据，而这个表目前在AWS DynamoDB中。我们可以通过两种方式为新推荐服务提供Post数据。

![](https://github.com/FHedy/DocItems/blob/main/source/Hacker%20News/img/15.png)

在单体架构中，推荐服务可以直接访问单体应用程序的同一持久化存储。这种方式的缺点如下：

- 缓存会变得很棘手，如果推荐服务共享了单体应用的缓存，我们就必须在推荐服务中复现缓存实现的细节；如果推荐服务使用自己的缓存，当单体应用更新Post数据时，我们不知道使缓存失效的正确时机。
- 如果单体应用决定更换数据库，例如从DynamoDB换成RDS，那么就需要重新实现推荐服务中的相关逻辑。
- 如果单体应用中解析Post数据时涉及到复杂的逻辑，例如如何决定是否将一个Post呈现给某个用户，在推荐服务中也需要实现这些逻辑。如果单体应用中添加或者修改了逻辑，那么推荐服务也得跟着变化。
- 单体服务使用了DynamoDB，那么推荐服务也就被卡在这个数据库，即使这个数据库的数据访问模式并不适合推荐服务。

在解耦的存储模型中，Post数据的实现细节仅保留在一个服务中，推荐服务不再直接访问Post数据，也不能直接访问任何其他新服务。如上图所示，有不同的方法可以实现这一目标。

- 方案A：理想情况下，应该有一个拥有Post数据的Post服务；其他服务只能通过Post服务的API访问Post数据。但是，为所有核心数据模型构建新服务可能需要成本高昂的前期投资。当人员配置有限时，还有一些更实用的方法。根据数据访问模式，它们可能是更好的选择。

- 方案B：单体应用程序会告知推荐服务何时更新相关的Post数据。通常，更新动作不需要立即执行，因此我们可以将其移入排队系统。
- 方案C：ETL管道为推荐服务生成Post数据的只读副本，以及可能对推荐有用的其他数据。

在B和C两个选项中，推荐服务完全拥有自己的数据，因此它可以灵活地缓存数据或使用最适合的数据库技术。

### 解耦“构建服务”和“运行服务”

如果构建微服务很难，那么运行服务往往更难。当运行服务与构建每个服务相结合时，工程团队的进展会减慢，团队必须不断重新调整计划。我们希望每项服务都专注于自己的工作，不用担心如何运行服务的复杂问题，包括网络、通信协议、部署和可观察性等方面。

服务管理应该与每个服务的实现完全分离。

> 将“构建服务”和“运行服务”分离的策略是使运行服务任务与服务技术相独立，以便应用工程师可以完全专注于每个服务本身的业务逻辑。

由于最近在容器化、容器编排、服务网格、应用程序性能监控等方面的技术进步，“运行服务”的解耦得以更容易实现。

**网络**

网络（例如，服务搜索、路由、负载平衡、流量路由等）是运行服务的关键部分。传统方法是为每种平台/语言提供库。这种方式有用但并不理想，因为应用程序仍然需要非常繁琐的工作来集成和维护库。通常应用程序仍然需要单独实现某些逻辑。最新的解决方案是在Service Mesh中运行服务。

在Medium，我们使用Istio和Envoy作为sidecar proxy，构建服务的应用工程师根本不需要担心网络问题。

**通信协议**

无论您选择哪种技术栈或语言来构建微服务，建议您选择一个高效、类型化、跨平台且需要最少开发成本的成熟RPC解决方案。支持向后兼容性的RPC解决方案能够更加安全地部署服务，即使服务之间存在依赖关系。

在Medium，我们选择了gRPC。一种常见的替代方案是基于HTTP的REST + JSON，它长期以来一直是服务器通信解决方案的福音。但是，尽管该堆栈非常适合浏览器与服务器通信，但它在服务器间通信效率很低。尤其是当我们需要发送大量请求时，如果没有自动生成的存根和样板代码，我们必须手动实现服务器/客户端代码。

可靠的RPC实现不仅仅可以打包网络客户端。此外，REST“有个性”，但让每个人对所有细节都达成一致是很困难的。例如，这个调用真的是REST，还是只是一个RPC？这是一种资源还是一种操作？等等问题。

**部署**

采用一致的方法来构建、测试、打包、部署和管理服务非常重要。Medium的所有微服务都在容器中运行，目前，我们的编排系统是AWS ECS和Kubernetes的混合体，但后续只会往Kubernetes方向迁移。

我们构建了自己的系统来构建、测试、打包和部署服务，称为BBFD。这种策略在跨服务持续工作和单独服务灵活采用不同技术栈之间实现了均衡。它的工作原理是让每个服务提供基本信息，例如要监听的端口、构建/测试/启动服务的命令等，其余的工作由BBFD负责。

### 彻底而一致的可观察性

可观察性包括可以让我们了解系统运行状态的过程、规范和工具，方便出现问题后快速定位。可观察性包括日志记录、性能跟踪、指标、仪表板、警报，这项策略对于微服务架构的成功至关重要。

当我们从单个服务迁移到具有多项服务的分布式系统时，可能会发生两件事：

1. 由于分布式系统复杂度高，很难监控，导致系统没有可观察性。
2. 不同团队重复造轮子，最终导致可观察性碎片化。而碎片化数据很难归类或定位任何问题，可观察性极低。

从一开始就具备良好且一致的可观察性非常重要，因此我们的DevOps团队提出了一致的可观察性策略，并构建了支持实现这一目标的工具。我们的每项服务都会自动获取详细的DataDog仪表板、警报和日志搜索，这些机制在所有服务中也是一致的。我们还大量使用LightStep来了解系统的性能。

### 并非每项新服务都需要从头开始构建

在微服务架构中，每项服务应专注于一个目的并做好，这与如何构建服务无关。请记住，如果从单体服务进行迁移，微服务并不是一定要从头开始构建，有时也可以尝试从单体应用程序中剥离。

从务实的角度来讲，是否要从头开始构建服务取决于两个因素：

1. Node.js是否适合该任务；
2. 在不同的技术栈中重新实现的成本是多少。

如果Node.js是一个很好的技术选项，而且现有的实现生态良好，我们可以选择把代码从单体应用程序中分离，然后用它创建一个微服务。即使采用相同的实现，我们仍能获得微服务架构的所有优势。

基于Node.js单体应用程序的架构，我们可以相对轻松地使用现有实现构建单独的服务。后续将讨论如何正确构建单体。

### 尊重失败

在分布式环境中，很多事情都有失败的可能性。如果处理不当，任务关键型服务的失败可能导致灾难性后果。因此，技术团队要经常思考如何做失败测试、如何很好地解决错误。

- 首要一点，我们随时要有面临出错的意识。
- 对于 RPC调用，要在处理错误上多做工作。
- 确保有充分的可观察性（如前文所述），在发生故障时进行监控。
- 上线新服务时要多做失败测试，整理出新服务检查清单。
- 尽可能构建自动恢复机制。

### 从开始就避免微服务综合症

微服务不是灵丹妙药，它能解决一些问题，但同时也会创造一些问题，我们将这些问题称为“ 微服务综合症 ”。

如果一开始没有考虑这些负面问题，那么事情可能会变得越来越糟糕，后续解决问题时需要花费更多成本和时间。

以下是一些常见的症状，供大家参照：

1. 微服务设计不良会导致弊大于利，特别是在有几个微服务时。
2. 允许太多不同的开发语言/技术并存，这会增加运维成本，分散工程组织的资源。
3. 将运行服务与构建服务耦合，这大大增加了每项服务的复杂性并减缓了团队的开发速度。
4. 忽略数据建模，最终得到的只是单体数据存储的微服务。
5. 缺乏可观察性，对性能问题或故障难以进行分类。
6. 当遇到问题时，团队倾向于创建新服务而不是修复现有服务，即便后者是更好的选择。
7. 即使服务是松耦合的，但是缺乏整个系统的整体画像也存在极大问题。

## 我们应该停止构建单体服务吗？

伴随着技术的不断创新，微服务架构的应用变得更加轻松。这是否意味着我们都应该停止构建单体服务？

答案是否定的，虽然得到新技术的加持，但微服务仍然是高度复杂的架构。对于小型团队来说，单体应用程序仍然是更好的选择。但是，随着系统的壮大和团队的成长，我们需要去研究如何设计单体应用程序的架构，以便今后能够更轻松地迁移到微服务架构。

> 单体架构须确保模块化，并应用上述三项微服务原则（单一性，松耦合和高内聚）来构建，但各项“服务”使用同一技术栈来实现、部署在一起并在同一进程中运行。

Medium在早期应用中得益于一些较好的单体应用相关决策。

我们的单体应用保持组件高度模块化，即使后来发展成为一个涵盖Web服务，后端服务和离线事件处理器的复杂应用。离线事件处理器单独运行，但使用的是完全相同的代码。这使得一大块业务逻辑可以相对容易地从单独服务中剥离出来，只要新服务提供的接口与原始实现相同（高级）即可。

我们的单体应用程序在较低层级封装了数据存储层，每种数据类型（例如，数据库表）都具有两层实现：*数据层*与*服务层*。

- *数据层*处理一种特定类型数据的CRUD操作。
- *服务层*处理一种特定类型数据的高级逻辑，并为系统的其余部分提供公共API。服务之间不共享数据存储。

这样有助于我们采用微服务架构，因为一种类型数据的实现细节完全隐藏在代码库的其它部分，创建新服务来处理特定数据类型时也相对安全便捷。

单体应用还可以帮我们对微服务进行建模，让我们得以专注于系统最重要的部分，不用再从头开始对所有微服务建模。

## 结论

单体Node.js应用程序为我们服务了好几年。随着项目复杂度越来越高，产品加快迭代，单体架构已力不从心。伴随着战略调整，我们开始系统地采用微服务架构。目前，我们仍然处于这一过程的早期阶段，但微服务已经展现出优势与潜力 - 它大大提高了开发效率，让我们能够更大胆地思考提升产品，让软件工程团队能够安全地测试新技术。

> **说明**：
>
> ¹ 本文中，“微服务”一词有两种含义，(1) 是指微服务架构；(2) 是指微服务架构中的一项服务。
>
> ² 开发过程中，访问生产数据是把双刃剑。这绝对是存在争议的，但如果我们能在确保数据安全的前提下访问，这便是强有效的测试。Medium声明：用户信息安全是的高压线，我们的所有测试未使用其他用户的数据，仅使用了内部工程师自己的个人账户。
